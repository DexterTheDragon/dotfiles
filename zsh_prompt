
autoload -U colors && colors
autoload -U promptinit
autoload -Uz vcs_info

local reset white gray green red yellow blue
reset="%{${reset_color}%}"
white="%{$fg[white]%}"
gray="%{$fg_bold[black]%}"
green="%{$fg_bold[green]%}"
red="%{$fg[red]%}"
b_red="%{$fg_bold[red]%}"
yellow="%{$fg[yellow]%}"
blue="%{$fg_bold[blue]%}"


# Executed before each prompt
function precmd {
    vcs_info
    set_prompt
    set_rprompt
}
# %{$bold_color$fg[green]%}%n@%m%{$reset_color%}:%{$bold_color$fg[blue]%}%~%{$reset_color%} $(__git_ps1 "(%s)")$(~/.rvm/bin/rvm-prompt 2>/dev/null)$(__bundler_ps1 "[%s]")\n%j %#

function set_prompt() {
    local -a lines infoline
    local x i filler i_width i_pad

    ### First, assemble the top line
    # Current dir; show in yellow if not writable
    [[ -w $PWD ]] && infoline+=( ${blue} ) || infoline+=( ${b_red} )
    infoline+=( "%~${reset} " )
    #
    # Username & host
    infoline+=( "%n" )
    [[ -n $SSH_CLIENT ]] && infoline+=( "@%m" )

    i_width=${(S)infoline//\%\{*\%\}} # search-and-replace color escapes
    i_width=${#${(%)i_width}} # expand all escapes and count the chars

    filler="${gray}${(l:$(( $COLUMNS - $i_width ))::.:)}${reset}"
    infoline[2]=( "${infoline[2]} ${filler} " )

    ### Now, assemble all prompt lines
    lines+=( ${(j::)infoline} )
    [[ -n ${vcs_info_msg_0_} ]] && lines+=( "${gray}${vcs_info_msg_0_}${reset}" )
    lines+=( "%(1j.${gray}%j${reset} .)%(0?.${white}.${red})%#${reset} " )

    ### Finally, set the prompt
    PROMPT=${(F)lines}
}

function set_rprompt() {
    local -a lines infoline
    local rvm bundler

    rvm=$(~/.rvm/bin/rvm-prompt 2>/dev/null)
    if [ $rvm ]; then
        infoline+=( "rvm:$rvm" )
    fi
    bundler=$(__bundler_ps1 "[%s]")
    if [ -n $bundler ]; then
        infoline+=( $bundler )
    fi
    if [[ -n $VIRTUAL_ENV ]]; then
        infoline+=( " venv:$(basename $VIRTUAL_ENV)" )
    fi

    lines+=( ${(j::)infoline} )

    if [[ -n $lines ]]; then
        RPROMPT="${white}${lines}${reset}"
    else
        RPROMPT=""
    fi
}
